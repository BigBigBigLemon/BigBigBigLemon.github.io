(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{358:function(t,e,v){t.exports=v.p+"assets/img/all.bb0e2a6c.jpg"},380:function(t,e,v){"use strict";v.r(e);var _=v(44),s=Object(_.a)({},(function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"性能优化之浏览器缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#性能优化之浏览器缓存"}},[t._v("#")]),t._v(" 性能优化之浏览器缓存")]),t._v(" "),_("h2",{attrs:{id:"前言"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),_("p",[t._v("在前端开发中，性能一直都是被大家所重视的一点，然而判断一个网站的性能最直观的就是看网页打开的速度。"),_("strong",[t._v("其中提高网页反应速度的一个方式就是使用缓存")]),t._v("。")]),t._v(" "),_("p",[t._v("缓存技术一直一来在WEB技术体系中扮演非常重要角色，是快速且有效地提升性能的手段。")]),t._v(" "),_("p",[t._v("一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。")]),t._v(" "),_("p",[_("strong",[t._v("在产品开发的时候我们总是想办法避免缓存产生，而在产品发布之时又在想策略管理缓存提升网页的访问速度")]),t._v("。")]),t._v(" "),_("p",[t._v("了解浏览器的缓存命中原理，是开发WEB应用的基础，本文着眼于此，学习浏览器缓存的相关知识，总结缓存避免和缓存管理的方法，结合具体的场景说明缓存的相关问题。")]),t._v(" "),_("h2",{attrs:{id:"认识浏览器缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#认识浏览器缓存"}},[t._v("#")]),t._v(" 认识浏览器缓存")]),t._v(" "),_("p",[t._v("当浏览器请求一个网站的时候，会加载各种各样的资源，比如：HTML文档、图片、CSS和JS等文件。对于一些不经常变的内容，浏览器会将他们保存在本地的文件中，下次访问相同网站的时候，直接加载这些资源，加速访问。")]),t._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),_("p",[t._v("这些被浏览器保存的文件就被称为缓存（不是指 Cookie 或者 Localstorage ）。")])]),t._v(" "),_("p",[t._v("那么如何知晓浏览器是读取了缓存还是直接请求服务器？")]),t._v(" "),_("p",[t._v("第一次打开该网站后，如果再次刷新页面。会发现浏览器加载的众多资源中，有一部分size有具体数值，然而还有一部分请求，比如图片、css和js等文件并没有显示文件大小，而是显示了 "),_("code",[t._v("from dis cache")]),t._v(" 或者 "),_("code",[t._v("from memory cache")]),t._v(" 字样。这就说明了，该资源直接从本地硬盘或者浏览器内存读取，而并没有请求服务器。")]),t._v(" "),_("p",[t._v("浏览器启用缓存至少有两点显而易见的好处：")]),t._v(" "),_("p",[_("strong",[t._v("（1）减少页面加载时间；")])]),t._v(" "),_("p",[_("strong",[t._v("（2）减少服务器负载；")])]),t._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),_("p",[t._v("浏览器是否使用缓存、缓存多久，是由服务器控制的。")])]),t._v(" "),_("p",[t._v("准确来说，当浏览器请求一个网页（或者其他资源）时，"),_("strong",[t._v("服务器发回的响应的「响应头」部分的某些字段指明了有关缓存的关键信息")]),t._v("。")]),t._v(" "),_("p",[t._v("下面看下，HTTP报文中与缓存相关的首部字段：")]),t._v(" "),_("h3",{attrs:{id:"_1-通用首部字段-就是请求报文和响应报文都能用上的字段"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-通用首部字段-就是请求报文和响应报文都能用上的字段"}},[t._v("#")]),t._v(" "),_("strong",[t._v("1.通用首部字段")]),t._v("（就是请求报文和响应报文都能用上的字段）")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",{staticStyle:{"text-align":"left"}},[t._v("字段名称")]),t._v(" "),_("th",[t._v("说明")])])]),t._v(" "),_("tbody",[_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("Cache-Control")]),t._v(" "),_("td",[t._v("控制缓存的行为")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("Pragma")]),t._v(" "),_("td",[t._v('HTTP1.0时代的遗留物，值为"no-cache"时禁用缓存')])])])]),t._v(" "),_("h3",{attrs:{id:"_2-请求首部字段"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-请求首部字段"}},[t._v("#")]),t._v(" "),_("strong",[t._v("2.请求首部字段")])]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",{staticStyle:{"text-align":"left"}},[t._v("字段名称")]),t._v(" "),_("th",[t._v("说明")])])]),t._v(" "),_("tbody",[_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("if-Match")]),t._v(" "),_("td",[t._v("比较ETag是否一致")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("if-None-Match")]),t._v(" "),_("td",[t._v("比较ETag是否不一致")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("if-Modified-Since")]),t._v(" "),_("td",[t._v("比较资源最后更新时间是否一致")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("if-Unmodified-Since")]),t._v(" "),_("td",[t._v("比较资源最后更新时间是否不一致")])])])]),t._v(" "),_("h3",{attrs:{id:"_3-响应首部字段"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-响应首部字段"}},[t._v("#")]),t._v(" "),_("strong",[t._v("3.响应首部字段")])]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",{staticStyle:{"text-align":"left"}},[t._v("字段名称")]),t._v(" "),_("th",[t._v("说明")])])]),t._v(" "),_("tbody",[_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("ETag")]),t._v(" "),_("td",[t._v("资源的匹配信息")])])])]),t._v(" "),_("h3",{attrs:{id:"_4-实体首部字段"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-实体首部字段"}},[t._v("#")]),t._v(" "),_("strong",[t._v("4.实体首部字段")])]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",{staticStyle:{"text-align":"left"}},[t._v("字段名称")]),t._v(" "),_("th",[t._v("说明")])])]),t._v(" "),_("tbody",[_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("Expires")]),t._v(" "),_("td",[t._v("HTTP1.0的遗留物，实体主题过期时间")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"left"}},[t._v("Last-Modified")]),t._v(" "),_("td",[t._v("资源的最后一次修改的时间")])])])]),t._v(" "),_("h2",{attrs:{id:"浏览器缓存机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存机制"}},[t._v("#")]),t._v(" 浏览器缓存机制")]),t._v(" "),_("p",[t._v("根据上面四种类型的首部字段不同使用策略，"),_("strong",[t._v("浏览器中缓存可分为强缓存和协商缓存")]),t._v("：")]),t._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),_("p",[t._v("1.浏览器在加载资源时，先根据这个资源的一些http header判断它是否命中强缓存，"),_("strong",[t._v("强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器")]),t._v("。比如：某个css文件，如果浏览器在加载它所在的网页时，这个css文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个css，连请求都不会发送到网页所在服务器；")]),t._v(" "),_("p",[t._v("2.当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，"),_("strong",[t._v("通过服务器端依据资源的另外一些http header验证这个资源是否命中协商缓存")]),t._v("，如果协商缓存命中，服务器会将这个请求返回，"),_("strong",[t._v("但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源")]),t._v("，于是浏览器就又会从自己的缓存中去加载这个资源；")]),t._v(" "),_("p",[t._v("3.强缓存与协商缓存的共同点是："),_("strong",[t._v("如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据")]),t._v("；区别是："),_("strong",[t._v("强缓存不发请求到服务器，协商缓存会发请求到服务器")]),t._v("。")]),t._v(" "),_("p",[t._v("4.当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。")])]),t._v(" "),_("h3",{attrs:{id:"强缓存-expires-cache-control"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#强缓存-expires-cache-control"}},[t._v("#")]),t._v(" 强缓存：Expires&Cache-Control")]),t._v(" "),_("p",[t._v("当浏览器对某个资源的请求命中了强缓存时，"),_("strong",[t._v("返回的HTTP状态为200")]),t._v("，在chrome的开发者工具的network里面 "),_("strong",[t._v("size会显示为from cache")]),t._v("，比如：京东的首页里就有很多静态资源配置了强缓存，用chrome打开几次，再用f12查看network，可以看到有不少请求就是从缓存中加载的。")]),t._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),_("p",[_("strong",[t._v("强缓存是利用Expires或者Cache-Control这两个http response header实现的，它们都用来表示资源在客户端缓存的有效期")]),t._v("。")])]),t._v(" "),_("p",[_("strong",[t._v("Expires是HTTP 1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回，用GMT格式的字符串表示")]),t._v("，如：Expires:Thu, 31 Dec 2037 23:55:55 GMT，包含了Expires头标签的文件，就说明浏览器对于该文件缓存具有非常大的控制权。")]),t._v(" "),_("p",[t._v("例如，一个文件的Expires值是2020年的1月1日，那么就代表，在2020年1月1日之前，浏览器都可以直接使用该文件的本地缓存文件，而不必去服务器再次请求该文件，哪怕服务器文件发生了变化。")]),t._v(" "),_("p",[t._v("所以，"),_("strong",[t._v("Expires是优化中最理想的情况，因为它根本不会产生请求")]),t._v("，所以后端也就无需考虑查询快慢。它的缓存原理，如下：")]),t._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),_("p",[t._v("​\t1.浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在response的header加上Expires的header；")]),t._v(" "),_("p",[t._v("​\t2.浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来（所以缓存命中的请求返回的header并不是来自服务器，而是来自之前缓存的header）；")]),t._v(" "),_("p",[t._v("​\t3.浏览器再请求这个资源时，"),_("strong",[t._v("先从缓存中寻找，找到这个资源后，拿出它的Expires跟当前的请求时间比较")]),t._v("，如果请求时间在Expires指定的时间之前，就能命中缓存，否则就不行；")]),t._v(" "),_("p",[t._v("​\t4.如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header在重新加载的时候会被更新；")])]),t._v(" "),_("p",[t._v("Expires是较老的强缓存管理header，"),_("strong",[t._v("由于它是服务器返回的一个绝对时间")]),t._v("，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，"),_("strong",[t._v("比如：随意修改下客户端时间，就能影响缓存命中的结果")]),t._v("。所以在HTTP 1.1的时候，提出了一个新的header，"),_("strong",[t._v("就是Cache-Control，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示")]),t._v("，如：Cache-Control:max-age=315360000，它的缓存原理是：")]),t._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),_("p",[t._v("​\t1.浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在response的header加上Cache-Control的header；")]),t._v(" "),_("p",[t._v("​\t2.浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来；")]),t._v(" "),_("p",[t._v("​\t3.浏览器再请求这个资源时，"),_("strong",[t._v("先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和Cache-Control设定的有效期")]),t._v("，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行；")]),t._v(" "),_("p",[t._v("​\t4.如果缓存没有命中，浏览器直接从服务器加载资源时，"),_("strong",[t._v("Cache-Control Header在重新加载的时候会被更新")]),t._v("；")])]),t._v(" "),_("p",[_("strong",[t._v("Cache-Control描述的是一个相对时间")]),t._v("，在进行缓存命中的时候，"),_("strong",[t._v("都是利用客户端时间进行判断")]),t._v("，所以相比较Expires，Cache-Control的缓存管理更有效，安全一些。")]),t._v(" "),_("p",[t._v("这两个header可以只启用一个，也可以同时启用，"),_("strong",[t._v("当response header中，Expires和Cache-Control同时存在时，Cache-Control优先级高于Expires")]),t._v("；")]),t._v(" "),_("p",[t._v("此外，还可以为 Cache-Control 指定 "),_("code",[t._v("public")]),t._v(" 或 "),_("code",[t._v("private")]),t._v(" 标记。"),_("strong",[t._v("如果使用 private，则表示该资源仅仅属于发出请求的最终用户，这将禁止中间服务器（如代理服务器）缓存此类资源")]),t._v("。对于包含用户个人信息的文件（如一个包含用户名的 HTML 文档），可以设置 private，一方面由于这些缓存对其他用户来说没有任何意义，另一方面用户可能不希望相关文件储存在不受信任的服务器上。需要指出的是，private 并不会使得缓存更加安全，它同样会传给中间服务器（如果网站对于传输的安全性要求很高，应该使用传输层安全措施）。"),_("strong",[t._v("对于 public，则允许所有服务器缓存该资源")]),t._v("。通常情况下，对于所有人都可以访问的资源（例如网站的 logo、图片、脚本等），"),_("strong",[t._v("Cache-Control 默认设为 public 是合理的")]),t._v("。")]),t._v(" "),_("h3",{attrs:{id:"协商缓存-last-modified-etag"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存-last-modified-etag"}},[t._v("#")]),t._v(" 协商缓存：Last-Modified & ETag")]),t._v(" "),_("p",[t._v("当浏览器对某个资源的请求没有命中强缓存，"),_("strong",[t._v("就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串")]),t._v("，比如你打开京东的首页，按f12打开开发者工具，再按f5刷新页面，查看network，可以看到有不少请求就是命中了协商缓存的；")]),t._v(" "),_("p",[t._v("查看单个请求的Response Header，"),_("strong",[t._v("也能看到304的状态码和Not Modified的字符串，只要看到这个就可说明这个资源是命中了协商缓存，然后从客户端缓存中加载的")]),t._v("，而不是服务器最新的资源；")]),t._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),_("p",[_("strong",[t._v("协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的")]),t._v("。")])]),t._v(" "),_("p",[_("strong",[t._v("【Last-Modified，If-Modified-Since】的控制缓存的原理，如下")]),t._v("：")]),t._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),_("p",[t._v("​\t1.浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，"),_("strong",[t._v("在response的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间")]),t._v("；")]),t._v(" "),_("p",[t._v("​\t2.浏览器再次跟服务器请求这个资源时，"),_("strong",[t._v("在request的header上加上If-Modified-Since的header")]),t._v("，这个header的值就是上一次请求时返回的Last-Modified的值；")]),t._v(" "),_("p",[t._v("​\t3.服务器再次收到资源请求时，"),_("strong",[t._v("根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化")]),t._v("，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。"),_("strong",[t._v("当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header")]),t._v("，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header；")]),t._v(" "),_("p",[t._v("​\t4.浏览器收到304的响应后，就会从缓存中加载资源；")]),t._v(" "),_("p",[t._v("​\t5.如果协商缓存没有命中，浏览器直接从服务器加载资源时，"),_("strong",[t._v("Last-Modified Header在重新加载的时候会被更新")]),t._v("，下次请求时，"),_("strong",[t._v("If-Modified-Since会启用上次返回的Last-Modified值")]),t._v("。")])]),t._v(" "),_("p",[t._v("【Last-Modified，If-Modified-Since】都是根据服务器时间返回的header，一般来说，"),_("strong",[t._v("在没有调整服务器时间和篡改客户端缓存的情况下，这两个header配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况")]),t._v("，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。"),_("strong",[t._v("所以就有了另外一对header来管理协商缓存，这对header就是【ETag、If-None-Match】")]),t._v("。它们的缓存管理的方式是：")]),t._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),_("p",[t._v("​\t1.浏览器第一次跟服务器请求一个资源，"),_("strong",[t._v("服务器在返回这个资源的同时，在response的header加上ETag的header")]),t._v("，这个header是服务器根据当前请求的资源生成的一个唯一标识，"),_("strong",[t._v("这个唯一标识是一个字符串，只要资源有变化这个串就不同")]),t._v("，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题；")]),t._v(" "),_("p",[t._v("​\t2.浏览器再次跟服务器请求这个资源时，"),_("strong",[t._v("在request的header上加上If-None-Match的header")]),t._v("，这个header的值就是上一次请求时返回的ETag的值；")]),t._v(" "),_("p",[t._v("​\t3.服务器再次收到资源请求时，"),_("strong",[t._v("根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag")]),t._v("，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，"),_("strong",[t._v("由于ETag重新生成过，response header中还会把这个ETag返回")]),t._v("，即使这个ETag跟之前的没有变化；")]),t._v(" "),_("p",[t._v("4.浏览器收到304的响应后，就会从缓存中加载资源。")])]),t._v(" "),_("p",[t._v("ETag和Last-Modified非常相似，都是用来判断一个参数，从而决定是否启用缓存。"),_("strong",[t._v("但是ETag相对于Last-Modified也有其优势，可以更加准确的判断文件内容是否被修改")]),t._v("，从而在实际操作中实用程度也更高。")]),t._v(" "),_("p",[t._v("协商缓存跟强缓存不一样，强缓存不发请求到服务器，"),_("strong",[t._v("所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器")]),t._v("，所以资源是否更新，服务器肯定知道。大部分web服务器都默认开启协商缓存，而且是同时启用【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】。")]),t._v(" "),_("p",[t._v("如果没有协商缓存，每个到服务器的请求，就都得返回资源内容，这样服务器的性能会极差。")]),t._v(" "),_("h2",{attrs:{id:"缓存判断流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缓存判断流程"}},[t._v("#")]),t._v(" 缓存判断流程")]),t._v(" "),_("p",[t._v("如果资源已经被浏览器缓存下来，在缓存失效之前，再次请求时，默认会先检查是否命中强缓存，如果强缓存命中则直接读取缓存，如果强缓存没有命中则发请求到服务器检查是否命中协商缓存，如果协商缓存命中，则告诉浏览器还是可以从缓存读取，否则才从服务器返回最新的资源。其浏览器判断缓存的详细流程图，如下：")]),t._v(" "),_("p",[_("img",{attrs:{src:v(358),alt:"浏览器判断缓存流程图"}})]),t._v(" "),_("h2",{attrs:{id:"其他参考资料"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#其他参考资料"}},[t._v("#")]),t._v(" 其他参考资料")]),t._v(" "),_("p",[t._v("1.http://www.alloyteam.com/2016/03/discussion-on-web-caching/")]),t._v(" "),_("p",[t._v("2.https://www.cnblogs.com/vajoy/p/5341664.html")])])}),[],!1,null,null,null);e.default=s.exports}}]);