<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>性能优化之浏览器缓存 | Monster&#39;s Blog</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/gh-page.ico">
    <meta name="description" content="welcome">
    
    <link rel="preload" href="/assets/css/0.styles.e4d8b86b.css" as="style"><link rel="preload" href="/assets/js/app.1cd9a0bd.js" as="script"><link rel="preload" href="/assets/js/2.022c84aa.js" as="script"><link rel="preload" href="/assets/js/7.34ecf688.js" as="script"><link rel="prefetch" href="/assets/js/10.97869133.js"><link rel="prefetch" href="/assets/js/11.d2e5c497.js"><link rel="prefetch" href="/assets/js/3.b4084cc6.js"><link rel="prefetch" href="/assets/js/4.e63a9f6f.js"><link rel="prefetch" href="/assets/js/5.f5fbed69.js"><link rel="prefetch" href="/assets/js/6.514d66bf.js"><link rel="prefetch" href="/assets/js/8.401397ca.js"><link rel="prefetch" href="/assets/js/9.f350cfe6.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e4d8b86b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Monster's Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/guide/" class="nav-link">
  Guide
</a></div><div class="nav-item"><a href="/git/" class="nav-link">
  GitHub
</a></div><div class="nav-item"><a href="/interview/" class="nav-link">
  InterView
</a></div><div class="nav-item"><a href="/cache/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  浏览器缓存
</a></div><div class="nav-item"><a href="https://github.com/BigBigBigLemon" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Monster
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/guide/" class="nav-link">
  Guide
</a></div><div class="nav-item"><a href="/git/" class="nav-link">
  GitHub
</a></div><div class="nav-item"><a href="/interview/" class="nav-link">
  InterView
</a></div><div class="nav-item"><a href="/cache/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  浏览器缓存
</a></div><div class="nav-item"><a href="https://github.com/BigBigBigLemon" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Monster
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>性能优化之浏览器缓存</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/cache/#前言" class="sidebar-link">前言</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/cache/#认识浏览器缓存" class="sidebar-link">认识浏览器缓存</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cache/#_1-通用首部字段-就是请求报文和响应报文都能用上的字段" class="sidebar-link">1.通用首部字段（就是请求报文和响应报文都能用上的字段）</a></li><li class="sidebar-sub-header"><a href="/cache/#_2-请求首部字段" class="sidebar-link">2.请求首部字段</a></li><li class="sidebar-sub-header"><a href="/cache/#_3-响应首部字段" class="sidebar-link">3.响应首部字段</a></li><li class="sidebar-sub-header"><a href="/cache/#_4-实体首部字段" class="sidebar-link">4.实体首部字段</a></li></ul></li><li><a href="/cache/#浏览器缓存机制" class="sidebar-link">浏览器缓存机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cache/#强缓存-expires-cache-control" class="sidebar-link">强缓存：Expires&amp;Cache-Control</a></li><li class="sidebar-sub-header"><a href="/cache/#协商缓存-last-modified-etag" class="sidebar-link">协商缓存：Last-Modified &amp; ETag</a></li></ul></li><li><a href="/cache/#缓存判断流程" class="sidebar-link">缓存判断流程</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/cache/#其他参考资料" class="sidebar-link">其他参考资料</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="性能优化之浏览器缓存"><a href="#性能优化之浏览器缓存" class="header-anchor">#</a> 性能优化之浏览器缓存</h1> <h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>在前端开发中，性能一直都是被大家所重视的一点，然而判断一个网站的性能最直观的就是看网页打开的速度。<strong>其中提高网页反应速度的一个方式就是使用缓存</strong>。</p> <p>缓存技术一直一来在WEB技术体系中扮演非常重要角色，是快速且有效地提升性能的手段。</p> <p>一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。</p> <p><strong>在产品开发的时候我们总是想办法避免缓存产生，而在产品发布之时又在想策略管理缓存提升网页的访问速度</strong>。</p> <p>了解浏览器的缓存命中原理，是开发WEB应用的基础，本文着眼于此，学习浏览器缓存的相关知识，总结缓存避免和缓存管理的方法，结合具体的场景说明缓存的相关问题。</p> <h2 id="认识浏览器缓存"><a href="#认识浏览器缓存" class="header-anchor">#</a> 认识浏览器缓存</h2> <p>当浏览器请求一个网站的时候，会加载各种各样的资源，比如：HTML文档、图片、CSS和JS等文件。对于一些不经常变的内容，浏览器会将他们保存在本地的文件中，下次访问相同网站的时候，直接加载这些资源，加速访问。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>这些被浏览器保存的文件就被称为缓存（不是指 Cookie 或者 Localstorage ）。</p></div> <p>那么如何知晓浏览器是读取了缓存还是直接请求服务器？</p> <p>第一次打开该网站后，如果再次刷新页面。会发现浏览器加载的众多资源中，有一部分size有具体数值，然而还有一部分请求，比如图片、css和js等文件并没有显示文件大小，而是显示了 <code>from dis cache</code> 或者 <code>from memory cache</code> 字样。这就说明了，该资源直接从本地硬盘或者浏览器内存读取，而并没有请求服务器。</p> <p>浏览器启用缓存至少有两点显而易见的好处：</p> <p><strong>（1）减少页面加载时间；</strong></p> <p><strong>（2）减少服务器负载；</strong></p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>浏览器是否使用缓存、缓存多久，是由服务器控制的。</p></div> <p>准确来说，当浏览器请求一个网页（或者其他资源）时，<strong>服务器发回的响应的「响应头」部分的某些字段指明了有关缓存的关键信息</strong>。</p> <p>下面看下，HTTP报文中与缓存相关的首部字段：</p> <h3 id="_1-通用首部字段-就是请求报文和响应报文都能用上的字段"><a href="#_1-通用首部字段-就是请求报文和响应报文都能用上的字段" class="header-anchor">#</a> <strong>1.通用首部字段</strong>（就是请求报文和响应报文都能用上的字段）</h3> <table><thead><tr><th style="text-align:left;">字段名称</th> <th>说明</th></tr></thead> <tbody><tr><td style="text-align:left;">Cache-Control</td> <td>控制缓存的行为</td></tr> <tr><td style="text-align:left;">Pragma</td> <td>HTTP1.0时代的遗留物，值为&quot;no-cache&quot;时禁用缓存</td></tr></tbody></table> <h3 id="_2-请求首部字段"><a href="#_2-请求首部字段" class="header-anchor">#</a> <strong>2.请求首部字段</strong></h3> <table><thead><tr><th style="text-align:left;">字段名称</th> <th>说明</th></tr></thead> <tbody><tr><td style="text-align:left;">if-Match</td> <td>比较ETag是否一致</td></tr> <tr><td style="text-align:left;">if-None-Match</td> <td>比较ETag是否不一致</td></tr> <tr><td style="text-align:left;">if-Modified-Since</td> <td>比较资源最后更新时间是否一致</td></tr> <tr><td style="text-align:left;">if-Unmodified-Since</td> <td>比较资源最后更新时间是否不一致</td></tr></tbody></table> <h3 id="_3-响应首部字段"><a href="#_3-响应首部字段" class="header-anchor">#</a> <strong>3.响应首部字段</strong></h3> <table><thead><tr><th style="text-align:left;">字段名称</th> <th>说明</th></tr></thead> <tbody><tr><td style="text-align:left;">ETag</td> <td>资源的匹配信息</td></tr></tbody></table> <h3 id="_4-实体首部字段"><a href="#_4-实体首部字段" class="header-anchor">#</a> <strong>4.实体首部字段</strong></h3> <table><thead><tr><th style="text-align:left;">字段名称</th> <th>说明</th></tr></thead> <tbody><tr><td style="text-align:left;">Expires</td> <td>HTTP1.0的遗留物，实体主题过期时间</td></tr> <tr><td style="text-align:left;">Last-Modified</td> <td>资源的最后一次修改的时间</td></tr></tbody></table> <h2 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="header-anchor">#</a> 浏览器缓存机制</h2> <p>根据上面四种类型的首部字段不同使用策略，<strong>浏览器中缓存可分为强缓存和协商缓存</strong>：</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>1.浏览器在加载资源时，先根据这个资源的一些http header判断它是否命中强缓存，<strong>强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器</strong>。比如：某个css文件，如果浏览器在加载它所在的网页时，这个css文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个css，连请求都不会发送到网页所在服务器；</p> <p>2.当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，<strong>通过服务器端依据资源的另外一些http header验证这个资源是否命中协商缓存</strong>，如果协商缓存命中，服务器会将这个请求返回，<strong>但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源</strong>，于是浏览器就又会从自己的缓存中去加载这个资源；</p> <p>3.强缓存与协商缓存的共同点是：<strong>如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据</strong>；区别是：<strong>强缓存不发请求到服务器，协商缓存会发请求到服务器</strong>。</p> <p>4.当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。</p></div> <h3 id="强缓存-expires-cache-control"><a href="#强缓存-expires-cache-control" class="header-anchor">#</a> 强缓存：Expires&amp;Cache-Control</h3> <p>当浏览器对某个资源的请求命中了强缓存时，<strong>返回的HTTP状态为200</strong>，在chrome的开发者工具的network里面 <strong>size会显示为from cache</strong>，比如：京东的首页里就有很多静态资源配置了强缓存，用chrome打开几次，再用f12查看network，可以看到有不少请求就是从缓存中加载的。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p><strong>强缓存是利用Expires或者Cache-Control这两个http response header实现的，它们都用来表示资源在客户端缓存的有效期</strong>。</p></div> <p><strong>Expires是HTTP 1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回，用GMT格式的字符串表示</strong>，如：Expires:Thu, 31 Dec 2037 23:55:55 GMT，包含了Expires头标签的文件，就说明浏览器对于该文件缓存具有非常大的控制权。</p> <p>例如，一个文件的Expires值是2020年的1月1日，那么就代表，在2020年1月1日之前，浏览器都可以直接使用该文件的本地缓存文件，而不必去服务器再次请求该文件，哪怕服务器文件发生了变化。</p> <p>所以，<strong>Expires是优化中最理想的情况，因为它根本不会产生请求</strong>，所以后端也就无需考虑查询快慢。它的缓存原理，如下：</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>​	1.浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在response的header加上Expires的header；</p> <p>​	2.浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来（所以缓存命中的请求返回的header并不是来自服务器，而是来自之前缓存的header）；</p> <p>​	3.浏览器再请求这个资源时，<strong>先从缓存中寻找，找到这个资源后，拿出它的Expires跟当前的请求时间比较</strong>，如果请求时间在Expires指定的时间之前，就能命中缓存，否则就不行；</p> <p>​	4.如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header在重新加载的时候会被更新；</p></div> <p>Expires是较老的强缓存管理header，<strong>由于它是服务器返回的一个绝对时间</strong>，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，<strong>比如：随意修改下客户端时间，就能影响缓存命中的结果</strong>。所以在HTTP 1.1的时候，提出了一个新的header，<strong>就是Cache-Control，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示</strong>，如：Cache-Control:max-age=315360000，它的缓存原理是：</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>​	1.浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在response的header加上Cache-Control的header；</p> <p>​	2.浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来；</p> <p>​	3.浏览器再请求这个资源时，<strong>先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和Cache-Control设定的有效期</strong>，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行；</p> <p>​	4.如果缓存没有命中，浏览器直接从服务器加载资源时，<strong>Cache-Control Header在重新加载的时候会被更新</strong>；</p></div> <p><strong>Cache-Control描述的是一个相对时间</strong>，在进行缓存命中的时候，<strong>都是利用客户端时间进行判断</strong>，所以相比较Expires，Cache-Control的缓存管理更有效，安全一些。</p> <p>这两个header可以只启用一个，也可以同时启用，<strong>当response header中，Expires和Cache-Control同时存在时，Cache-Control优先级高于Expires</strong>；</p> <p>此外，还可以为 Cache-Control 指定 <code>public</code> 或 <code>private</code> 标记。<strong>如果使用 private，则表示该资源仅仅属于发出请求的最终用户，这将禁止中间服务器（如代理服务器）缓存此类资源</strong>。对于包含用户个人信息的文件（如一个包含用户名的 HTML 文档），可以设置 private，一方面由于这些缓存对其他用户来说没有任何意义，另一方面用户可能不希望相关文件储存在不受信任的服务器上。需要指出的是，private 并不会使得缓存更加安全，它同样会传给中间服务器（如果网站对于传输的安全性要求很高，应该使用传输层安全措施）。<strong>对于 public，则允许所有服务器缓存该资源</strong>。通常情况下，对于所有人都可以访问的资源（例如网站的 logo、图片、脚本等），<strong>Cache-Control 默认设为 public 是合理的</strong>。</p> <h3 id="协商缓存-last-modified-etag"><a href="#协商缓存-last-modified-etag" class="header-anchor">#</a> 协商缓存：Last-Modified &amp; ETag</h3> <p>当浏览器对某个资源的请求没有命中强缓存，<strong>就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串</strong>，比如你打开京东的首页，按f12打开开发者工具，再按f5刷新页面，查看network，可以看到有不少请求就是命中了协商缓存的；</p> <p>查看单个请求的Response Header，<strong>也能看到304的状态码和Not Modified的字符串，只要看到这个就可说明这个资源是命中了协商缓存，然后从客户端缓存中加载的</strong>，而不是服务器最新的资源；</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p><strong>协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的</strong>。</p></div> <p><strong>【Last-Modified，If-Modified-Since】的控制缓存的原理，如下</strong>：</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>​	1.浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，<strong>在response的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间</strong>；</p> <p>​	2.浏览器再次跟服务器请求这个资源时，<strong>在request的header上加上If-Modified-Since的header</strong>，这个header的值就是上一次请求时返回的Last-Modified的值；</p> <p>​	3.服务器再次收到资源请求时，<strong>根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化</strong>，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。<strong>当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header</strong>，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header；</p> <p>​	4.浏览器收到304的响应后，就会从缓存中加载资源；</p> <p>​	5.如果协商缓存没有命中，浏览器直接从服务器加载资源时，<strong>Last-Modified Header在重新加载的时候会被更新</strong>，下次请求时，<strong>If-Modified-Since会启用上次返回的Last-Modified值</strong>。</p></div> <p>【Last-Modified，If-Modified-Since】都是根据服务器时间返回的header，一般来说，<strong>在没有调整服务器时间和篡改客户端缓存的情况下，这两个header配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况</strong>，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。<strong>所以就有了另外一对header来管理协商缓存，这对header就是【ETag、If-None-Match】</strong>。它们的缓存管理的方式是：</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>​	1.浏览器第一次跟服务器请求一个资源，<strong>服务器在返回这个资源的同时，在response的header加上ETag的header</strong>，这个header是服务器根据当前请求的资源生成的一个唯一标识，<strong>这个唯一标识是一个字符串，只要资源有变化这个串就不同</strong>，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题；</p> <p>​	2.浏览器再次跟服务器请求这个资源时，<strong>在request的header上加上If-None-Match的header</strong>，这个header的值就是上一次请求时返回的ETag的值；</p> <p>​	3.服务器再次收到资源请求时，<strong>根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag</strong>，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，<strong>由于ETag重新生成过，response header中还会把这个ETag返回</strong>，即使这个ETag跟之前的没有变化；</p> <p>4.浏览器收到304的响应后，就会从缓存中加载资源。</p></div> <p>ETag和Last-Modified非常相似，都是用来判断一个参数，从而决定是否启用缓存。<strong>但是ETag相对于Last-Modified也有其优势，可以更加准确的判断文件内容是否被修改</strong>，从而在实际操作中实用程度也更高。</p> <p>协商缓存跟强缓存不一样，强缓存不发请求到服务器，<strong>所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器</strong>，所以资源是否更新，服务器肯定知道。大部分web服务器都默认开启协商缓存，而且是同时启用【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】。</p> <p>如果没有协商缓存，每个到服务器的请求，就都得返回资源内容，这样服务器的性能会极差。</p> <h2 id="缓存判断流程"><a href="#缓存判断流程" class="header-anchor">#</a> 缓存判断流程</h2> <p>如果资源已经被浏览器缓存下来，在缓存失效之前，再次请求时，默认会先检查是否命中强缓存，如果强缓存命中则直接读取缓存，如果强缓存没有命中则发请求到服务器检查是否命中协商缓存，如果协商缓存命中，则告诉浏览器还是可以从缓存读取，否则才从服务器返回最新的资源。其浏览器判断缓存的详细流程图，如下：</p> <p><img src="/assets/img/all.bb0e2a6c.jpg" alt="浏览器判断缓存流程图"></p> <h2 id="其他参考资料"><a href="#其他参考资料" class="header-anchor">#</a> 其他参考资料</h2> <p>1.http://www.alloyteam.com/2016/03/discussion-on-web-caching/</p> <p>2.https://www.cnblogs.com/vajoy/p/5341664.html</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">7/7/2021, 5:18:05 AM</span></div></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.1cd9a0bd.js" defer></script><script src="/assets/js/2.022c84aa.js" defer></script><script src="/assets/js/7.34ecf688.js" defer></script>
  </body>
</html>
